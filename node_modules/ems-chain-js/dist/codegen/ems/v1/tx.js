"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgUpdateEventStatusResponse = exports.MsgUpdateEventStatusParams = exports.MsgAddEventOrganizerResponse = exports.MsgAddEventOrganizerParams = exports.MsgIssueEventNFTResponse = exports.MsgIssueEventNFTParams = exports.MsgCreateEventResponse = exports.MsgCreateEventParams = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = void 0;
const genesis_1 = require("./genesis");
const binary_1 = require("../../binary");
function createBaseMsgUpdateParams() {
    return {
        authority: "",
        params: genesis_1.Params.fromPartial({})
    };
}
exports.MsgUpdateParams = {
    typeUrl: "/ems.v1.MsgUpdateParams",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
            writer.uint32(10).string(message.authority);
        }
        if (message.params !== undefined) {
            genesis_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.authority = reader.string();
                    break;
                case 2:
                    message.params = genesis_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        message.params = object.params !== undefined && object.params !== null ? genesis_1.Params.fromPartial(object.params) : undefined;
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgUpdateParams();
        if (object.authority !== undefined && object.authority !== null) {
            message.authority = object.authority;
        }
        if (object.params !== undefined && object.params !== null) {
            message.params = genesis_1.Params.fromAmino(object.params);
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.authority = message.authority === "" ? undefined : message.authority;
        obj.params = message.params ? genesis_1.Params.toAmino(message.params) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgUpdateParams.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgUpdateParams.decode(message.value);
    },
    toProto(message) {
        return exports.MsgUpdateParams.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgUpdateParams",
            value: exports.MsgUpdateParams.encode(message).finish()
        };
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    typeUrl: "/ems.v1.MsgUpdateParamsResponse",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgUpdateParamsResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgUpdateParamsResponse.decode(message.value);
    },
    toProto(message) {
        return exports.MsgUpdateParamsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgUpdateParamsResponse",
            value: exports.MsgUpdateParamsResponse.encode(message).finish()
        };
    }
};
function createBaseMsgCreateEventParams() {
    return {
        organizer: "",
        name: "",
        id: "",
        nftPrice: 0,
        tokenPrice: 0,
        tokenSupply: BigInt(0),
        maxOrganizers: 0
    };
}
exports.MsgCreateEventParams = {
    typeUrl: "/ems.v1.MsgCreateEventParams",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.organizer !== "") {
            writer.uint32(10).string(message.organizer);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.id !== "") {
            writer.uint32(26).string(message.id);
        }
        if (message.nftPrice !== 0) {
            writer.uint32(32).int32(message.nftPrice);
        }
        if (message.tokenPrice !== 0) {
            writer.uint32(40).int32(message.tokenPrice);
        }
        if (message.tokenSupply !== BigInt(0)) {
            writer.uint32(48).int64(message.tokenSupply);
        }
        if (message.maxOrganizers !== 0) {
            writer.uint32(56).int32(message.maxOrganizers);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateEventParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.organizer = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.id = reader.string();
                    break;
                case 4:
                    message.nftPrice = reader.int32();
                    break;
                case 5:
                    message.tokenPrice = reader.int32();
                    break;
                case 6:
                    message.tokenSupply = reader.int64();
                    break;
                case 7:
                    message.maxOrganizers = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgCreateEventParams();
        message.organizer = object.organizer ?? "";
        message.name = object.name ?? "";
        message.id = object.id ?? "";
        message.nftPrice = object.nftPrice ?? 0;
        message.tokenPrice = object.tokenPrice ?? 0;
        message.tokenSupply = object.tokenSupply !== undefined && object.tokenSupply !== null ? BigInt(object.tokenSupply.toString()) : BigInt(0);
        message.maxOrganizers = object.maxOrganizers ?? 0;
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgCreateEventParams();
        if (object.organizer !== undefined && object.organizer !== null) {
            message.organizer = object.organizer;
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = object.name;
        }
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        if (object.nft_price !== undefined && object.nft_price !== null) {
            message.nftPrice = object.nft_price;
        }
        if (object.token_price !== undefined && object.token_price !== null) {
            message.tokenPrice = object.token_price;
        }
        if (object.token_supply !== undefined && object.token_supply !== null) {
            message.tokenSupply = BigInt(object.token_supply);
        }
        if (object.max_organizers !== undefined && object.max_organizers !== null) {
            message.maxOrganizers = object.max_organizers;
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.organizer = message.organizer === "" ? undefined : message.organizer;
        obj.name = message.name === "" ? undefined : message.name;
        obj.id = message.id === "" ? undefined : message.id;
        obj.nft_price = message.nftPrice === 0 ? undefined : message.nftPrice;
        obj.token_price = message.tokenPrice === 0 ? undefined : message.tokenPrice;
        obj.token_supply = message.tokenSupply !== BigInt(0) ? (message.tokenSupply?.toString)() : undefined;
        obj.max_organizers = message.maxOrganizers === 0 ? undefined : message.maxOrganizers;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgCreateEventParams.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgCreateEventParams.decode(message.value);
    },
    toProto(message) {
        return exports.MsgCreateEventParams.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgCreateEventParams",
            value: exports.MsgCreateEventParams.encode(message).finish()
        };
    }
};
function createBaseMsgCreateEventResponse() {
    return {};
}
exports.MsgCreateEventResponse = {
    typeUrl: "/ems.v1.MsgCreateEventResponse",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateEventResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgCreateEventResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgCreateEventResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgCreateEventResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgCreateEventResponse.decode(message.value);
    },
    toProto(message) {
        return exports.MsgCreateEventResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgCreateEventResponse",
            value: exports.MsgCreateEventResponse.encode(message).finish()
        };
    }
};
function createBaseMsgIssueEventNFTParams() {
    return {
        receiver: "",
        id: "",
        nft: false
    };
}
exports.MsgIssueEventNFTParams = {
    typeUrl: "/ems.v1.MsgIssueEventNFTParams",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.receiver !== "") {
            writer.uint32(18).string(message.receiver);
        }
        if (message.id !== "") {
            writer.uint32(26).string(message.id);
        }
        if (message.nft === true) {
            writer.uint32(32).bool(message.nft);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgIssueEventNFTParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.receiver = reader.string();
                    break;
                case 3:
                    message.id = reader.string();
                    break;
                case 4:
                    message.nft = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgIssueEventNFTParams();
        message.receiver = object.receiver ?? "";
        message.id = object.id ?? "";
        message.nft = object.nft ?? false;
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgIssueEventNFTParams();
        if (object.receiver !== undefined && object.receiver !== null) {
            message.receiver = object.receiver;
        }
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        if (object.nft !== undefined && object.nft !== null) {
            message.nft = object.nft;
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.receiver = message.receiver === "" ? undefined : message.receiver;
        obj.id = message.id === "" ? undefined : message.id;
        obj.nft = message.nft === false ? undefined : message.nft;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgIssueEventNFTParams.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgIssueEventNFTParams.decode(message.value);
    },
    toProto(message) {
        return exports.MsgIssueEventNFTParams.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgIssueEventNFTParams",
            value: exports.MsgIssueEventNFTParams.encode(message).finish()
        };
    }
};
function createBaseMsgIssueEventNFTResponse() {
    return {};
}
exports.MsgIssueEventNFTResponse = {
    typeUrl: "/ems.v1.MsgIssueEventNFTResponse",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgIssueEventNFTResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgIssueEventNFTResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgIssueEventNFTResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgIssueEventNFTResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgIssueEventNFTResponse.decode(message.value);
    },
    toProto(message) {
        return exports.MsgIssueEventNFTResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgIssueEventNFTResponse",
            value: exports.MsgIssueEventNFTResponse.encode(message).finish()
        };
    }
};
function createBaseMsgAddEventOrganizerParams() {
    return {
        organizer: "",
        member: "",
        id: ""
    };
}
exports.MsgAddEventOrganizerParams = {
    typeUrl: "/ems.v1.MsgAddEventOrganizerParams",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.organizer !== "") {
            writer.uint32(10).string(message.organizer);
        }
        if (message.member !== "") {
            writer.uint32(18).string(message.member);
        }
        if (message.id !== "") {
            writer.uint32(26).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddEventOrganizerParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.organizer = reader.string();
                    break;
                case 2:
                    message.member = reader.string();
                    break;
                case 3:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgAddEventOrganizerParams();
        message.organizer = object.organizer ?? "";
        message.member = object.member ?? "";
        message.id = object.id ?? "";
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgAddEventOrganizerParams();
        if (object.organizer !== undefined && object.organizer !== null) {
            message.organizer = object.organizer;
        }
        if (object.member !== undefined && object.member !== null) {
            message.member = object.member;
        }
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.organizer = message.organizer === "" ? undefined : message.organizer;
        obj.member = message.member === "" ? undefined : message.member;
        obj.id = message.id === "" ? undefined : message.id;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgAddEventOrganizerParams.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgAddEventOrganizerParams.decode(message.value);
    },
    toProto(message) {
        return exports.MsgAddEventOrganizerParams.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgAddEventOrganizerParams",
            value: exports.MsgAddEventOrganizerParams.encode(message).finish()
        };
    }
};
function createBaseMsgAddEventOrganizerResponse() {
    return {};
}
exports.MsgAddEventOrganizerResponse = {
    typeUrl: "/ems.v1.MsgAddEventOrganizerResponse",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddEventOrganizerResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgAddEventOrganizerResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgAddEventOrganizerResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgAddEventOrganizerResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgAddEventOrganizerResponse.decode(message.value);
    },
    toProto(message) {
        return exports.MsgAddEventOrganizerResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgAddEventOrganizerResponse",
            value: exports.MsgAddEventOrganizerResponse.encode(message).finish()
        };
    }
};
function createBaseMsgUpdateEventStatusParams() {
    return {
        organizer: "",
        id: "",
        active: false
    };
}
exports.MsgUpdateEventStatusParams = {
    typeUrl: "/ems.v1.MsgUpdateEventStatusParams",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.organizer !== "") {
            writer.uint32(10).string(message.organizer);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.active === true) {
            writer.uint32(24).bool(message.active);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateEventStatusParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.organizer = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.active = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgUpdateEventStatusParams();
        message.organizer = object.organizer ?? "";
        message.id = object.id ?? "";
        message.active = object.active ?? false;
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgUpdateEventStatusParams();
        if (object.organizer !== undefined && object.organizer !== null) {
            message.organizer = object.organizer;
        }
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        if (object.active !== undefined && object.active !== null) {
            message.active = object.active;
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.organizer = message.organizer === "" ? undefined : message.organizer;
        obj.id = message.id === "" ? undefined : message.id;
        obj.active = message.active === false ? undefined : message.active;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgUpdateEventStatusParams.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgUpdateEventStatusParams.decode(message.value);
    },
    toProto(message) {
        return exports.MsgUpdateEventStatusParams.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgUpdateEventStatusParams",
            value: exports.MsgUpdateEventStatusParams.encode(message).finish()
        };
    }
};
function createBaseMsgUpdateEventStatusResponse() {
    return {};
}
exports.MsgUpdateEventStatusResponse = {
    typeUrl: "/ems.v1.MsgUpdateEventStatusResponse",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateEventStatusResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateEventStatusResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgUpdateEventStatusResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgUpdateEventStatusResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgUpdateEventStatusResponse.decode(message.value);
    },
    toProto(message) {
        return exports.MsgUpdateEventStatusResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgUpdateEventStatusResponse",
            value: exports.MsgUpdateEventStatusResponse.encode(message).finish()
        };
    }
};
//# sourceMappingURL=tx.js.map