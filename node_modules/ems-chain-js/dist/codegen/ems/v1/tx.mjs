import { Params } from "./genesis";
import { BinaryReader, BinaryWriter } from "../../binary";
function createBaseMsgUpdateParams() {
    return {
        authority: "",
        params: Params.fromPartial({})
    };
}
export const MsgUpdateParams = {
    typeUrl: "/ems.v1.MsgUpdateParams",
    encode(message, writer = BinaryWriter.create()) {
        if (message.authority !== "") {
            writer.uint32(10).string(message.authority);
        }
        if (message.params !== undefined) {
            Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.authority = reader.string();
                    break;
                case 2:
                    message.params = Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        message.params = object.params !== undefined && object.params !== null ? Params.fromPartial(object.params) : undefined;
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgUpdateParams();
        if (object.authority !== undefined && object.authority !== null) {
            message.authority = object.authority;
        }
        if (object.params !== undefined && object.params !== null) {
            message.params = Params.fromAmino(object.params);
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.authority = message.authority === "" ? undefined : message.authority;
        obj.params = message.params ? Params.toAmino(message.params) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgUpdateParams.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return MsgUpdateParams.decode(message.value);
    },
    toProto(message) {
        return MsgUpdateParams.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgUpdateParams",
            value: MsgUpdateParams.encode(message).finish()
        };
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
export const MsgUpdateParamsResponse = {
    typeUrl: "/ems.v1.MsgUpdateParamsResponse",
    encode(_, writer = BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return MsgUpdateParamsResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return MsgUpdateParamsResponse.decode(message.value);
    },
    toProto(message) {
        return MsgUpdateParamsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgUpdateParamsResponse",
            value: MsgUpdateParamsResponse.encode(message).finish()
        };
    }
};
function createBaseMsgCreateEventParams() {
    return {
        organizer: "",
        name: "",
        id: "",
        nftPrice: 0,
        tokenPrice: 0,
        tokenSupply: BigInt(0),
        maxOrganizers: 0
    };
}
export const MsgCreateEventParams = {
    typeUrl: "/ems.v1.MsgCreateEventParams",
    encode(message, writer = BinaryWriter.create()) {
        if (message.organizer !== "") {
            writer.uint32(10).string(message.organizer);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.id !== "") {
            writer.uint32(26).string(message.id);
        }
        if (message.nftPrice !== 0) {
            writer.uint32(32).int32(message.nftPrice);
        }
        if (message.tokenPrice !== 0) {
            writer.uint32(40).int32(message.tokenPrice);
        }
        if (message.tokenSupply !== BigInt(0)) {
            writer.uint32(48).int64(message.tokenSupply);
        }
        if (message.maxOrganizers !== 0) {
            writer.uint32(56).int32(message.maxOrganizers);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateEventParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.organizer = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.id = reader.string();
                    break;
                case 4:
                    message.nftPrice = reader.int32();
                    break;
                case 5:
                    message.tokenPrice = reader.int32();
                    break;
                case 6:
                    message.tokenSupply = reader.int64();
                    break;
                case 7:
                    message.maxOrganizers = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgCreateEventParams();
        message.organizer = object.organizer ?? "";
        message.name = object.name ?? "";
        message.id = object.id ?? "";
        message.nftPrice = object.nftPrice ?? 0;
        message.tokenPrice = object.tokenPrice ?? 0;
        message.tokenSupply = object.tokenSupply !== undefined && object.tokenSupply !== null ? BigInt(object.tokenSupply.toString()) : BigInt(0);
        message.maxOrganizers = object.maxOrganizers ?? 0;
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgCreateEventParams();
        if (object.organizer !== undefined && object.organizer !== null) {
            message.organizer = object.organizer;
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = object.name;
        }
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        if (object.nft_price !== undefined && object.nft_price !== null) {
            message.nftPrice = object.nft_price;
        }
        if (object.token_price !== undefined && object.token_price !== null) {
            message.tokenPrice = object.token_price;
        }
        if (object.token_supply !== undefined && object.token_supply !== null) {
            message.tokenSupply = BigInt(object.token_supply);
        }
        if (object.max_organizers !== undefined && object.max_organizers !== null) {
            message.maxOrganizers = object.max_organizers;
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.organizer = message.organizer === "" ? undefined : message.organizer;
        obj.name = message.name === "" ? undefined : message.name;
        obj.id = message.id === "" ? undefined : message.id;
        obj.nft_price = message.nftPrice === 0 ? undefined : message.nftPrice;
        obj.token_price = message.tokenPrice === 0 ? undefined : message.tokenPrice;
        obj.token_supply = message.tokenSupply !== BigInt(0) ? (message.tokenSupply?.toString)() : undefined;
        obj.max_organizers = message.maxOrganizers === 0 ? undefined : message.maxOrganizers;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgCreateEventParams.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return MsgCreateEventParams.decode(message.value);
    },
    toProto(message) {
        return MsgCreateEventParams.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgCreateEventParams",
            value: MsgCreateEventParams.encode(message).finish()
        };
    }
};
function createBaseMsgCreateEventResponse() {
    return {};
}
export const MsgCreateEventResponse = {
    typeUrl: "/ems.v1.MsgCreateEventResponse",
    encode(_, writer = BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateEventResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgCreateEventResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgCreateEventResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return MsgCreateEventResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return MsgCreateEventResponse.decode(message.value);
    },
    toProto(message) {
        return MsgCreateEventResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgCreateEventResponse",
            value: MsgCreateEventResponse.encode(message).finish()
        };
    }
};
function createBaseMsgIssueEventNFTParams() {
    return {
        receiver: "",
        id: "",
        nft: false
    };
}
export const MsgIssueEventNFTParams = {
    typeUrl: "/ems.v1.MsgIssueEventNFTParams",
    encode(message, writer = BinaryWriter.create()) {
        if (message.receiver !== "") {
            writer.uint32(18).string(message.receiver);
        }
        if (message.id !== "") {
            writer.uint32(26).string(message.id);
        }
        if (message.nft === true) {
            writer.uint32(32).bool(message.nft);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgIssueEventNFTParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.receiver = reader.string();
                    break;
                case 3:
                    message.id = reader.string();
                    break;
                case 4:
                    message.nft = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgIssueEventNFTParams();
        message.receiver = object.receiver ?? "";
        message.id = object.id ?? "";
        message.nft = object.nft ?? false;
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgIssueEventNFTParams();
        if (object.receiver !== undefined && object.receiver !== null) {
            message.receiver = object.receiver;
        }
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        if (object.nft !== undefined && object.nft !== null) {
            message.nft = object.nft;
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.receiver = message.receiver === "" ? undefined : message.receiver;
        obj.id = message.id === "" ? undefined : message.id;
        obj.nft = message.nft === false ? undefined : message.nft;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgIssueEventNFTParams.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return MsgIssueEventNFTParams.decode(message.value);
    },
    toProto(message) {
        return MsgIssueEventNFTParams.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgIssueEventNFTParams",
            value: MsgIssueEventNFTParams.encode(message).finish()
        };
    }
};
function createBaseMsgIssueEventNFTResponse() {
    return {};
}
export const MsgIssueEventNFTResponse = {
    typeUrl: "/ems.v1.MsgIssueEventNFTResponse",
    encode(_, writer = BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgIssueEventNFTResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgIssueEventNFTResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgIssueEventNFTResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return MsgIssueEventNFTResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return MsgIssueEventNFTResponse.decode(message.value);
    },
    toProto(message) {
        return MsgIssueEventNFTResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgIssueEventNFTResponse",
            value: MsgIssueEventNFTResponse.encode(message).finish()
        };
    }
};
function createBaseMsgAddEventOrganizerParams() {
    return {
        organizer: "",
        member: "",
        id: ""
    };
}
export const MsgAddEventOrganizerParams = {
    typeUrl: "/ems.v1.MsgAddEventOrganizerParams",
    encode(message, writer = BinaryWriter.create()) {
        if (message.organizer !== "") {
            writer.uint32(10).string(message.organizer);
        }
        if (message.member !== "") {
            writer.uint32(18).string(message.member);
        }
        if (message.id !== "") {
            writer.uint32(26).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddEventOrganizerParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.organizer = reader.string();
                    break;
                case 2:
                    message.member = reader.string();
                    break;
                case 3:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgAddEventOrganizerParams();
        message.organizer = object.organizer ?? "";
        message.member = object.member ?? "";
        message.id = object.id ?? "";
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgAddEventOrganizerParams();
        if (object.organizer !== undefined && object.organizer !== null) {
            message.organizer = object.organizer;
        }
        if (object.member !== undefined && object.member !== null) {
            message.member = object.member;
        }
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.organizer = message.organizer === "" ? undefined : message.organizer;
        obj.member = message.member === "" ? undefined : message.member;
        obj.id = message.id === "" ? undefined : message.id;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgAddEventOrganizerParams.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return MsgAddEventOrganizerParams.decode(message.value);
    },
    toProto(message) {
        return MsgAddEventOrganizerParams.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgAddEventOrganizerParams",
            value: MsgAddEventOrganizerParams.encode(message).finish()
        };
    }
};
function createBaseMsgAddEventOrganizerResponse() {
    return {};
}
export const MsgAddEventOrganizerResponse = {
    typeUrl: "/ems.v1.MsgAddEventOrganizerResponse",
    encode(_, writer = BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddEventOrganizerResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgAddEventOrganizerResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgAddEventOrganizerResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return MsgAddEventOrganizerResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return MsgAddEventOrganizerResponse.decode(message.value);
    },
    toProto(message) {
        return MsgAddEventOrganizerResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgAddEventOrganizerResponse",
            value: MsgAddEventOrganizerResponse.encode(message).finish()
        };
    }
};
function createBaseMsgUpdateEventStatusParams() {
    return {
        organizer: "",
        id: "",
        active: false
    };
}
export const MsgUpdateEventStatusParams = {
    typeUrl: "/ems.v1.MsgUpdateEventStatusParams",
    encode(message, writer = BinaryWriter.create()) {
        if (message.organizer !== "") {
            writer.uint32(10).string(message.organizer);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.active === true) {
            writer.uint32(24).bool(message.active);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateEventStatusParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.organizer = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.active = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgUpdateEventStatusParams();
        message.organizer = object.organizer ?? "";
        message.id = object.id ?? "";
        message.active = object.active ?? false;
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgUpdateEventStatusParams();
        if (object.organizer !== undefined && object.organizer !== null) {
            message.organizer = object.organizer;
        }
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        if (object.active !== undefined && object.active !== null) {
            message.active = object.active;
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.organizer = message.organizer === "" ? undefined : message.organizer;
        obj.id = message.id === "" ? undefined : message.id;
        obj.active = message.active === false ? undefined : message.active;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgUpdateEventStatusParams.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return MsgUpdateEventStatusParams.decode(message.value);
    },
    toProto(message) {
        return MsgUpdateEventStatusParams.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgUpdateEventStatusParams",
            value: MsgUpdateEventStatusParams.encode(message).finish()
        };
    }
};
function createBaseMsgUpdateEventStatusResponse() {
    return {};
}
export const MsgUpdateEventStatusResponse = {
    typeUrl: "/ems.v1.MsgUpdateEventStatusResponse",
    encode(_, writer = BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateEventStatusResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateEventStatusResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgUpdateEventStatusResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return MsgUpdateEventStatusResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return MsgUpdateEventStatusResponse.decode(message.value);
    },
    toProto(message) {
        return MsgUpdateEventStatusResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/ems.v1.MsgUpdateEventStatusResponse",
            value: MsgUpdateEventStatusResponse.encode(message).finish()
        };
    }
};
//# sourceMappingURL=tx.js.map